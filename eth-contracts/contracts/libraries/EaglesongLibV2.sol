// SPDX-License-Identifier: MIT
pragma solidity ^0.6.6;

library EaglesongLibV2 {
    uint256 constant x0 = 0x6e9e40ae71927c029a13d3b1daec32ad3d8951cfe1c9fe9ab806b54cacbbf417;
    uint256 constant x1 = 0xd3622b3ba082762a9edcf1c0a9bada777f91e46ccb0f6e4f265d9241b7bdeab0;
    uint256 constant x2 = 0x6260c9e6ff50dd2a9036aa71ce161879d1307cdf89e456dff83133e265f55c3d;
    uint256 constant x3 = 0x94871b01b5d204cd583a32645e1659574cbda964675fca47f4a3033e2a417322;
    uint256 constant x4 = 0x3b61432f7f5532f2b609973b1a79523931b477c9d2949d28789697120eb87b6e;
    uint256 constant x5 = 0x7e11d22dccee88bdeed07eb8e5563a81e7cb6bcf25de953e4d05653a0b831557;
    uint256 constant x6 = 0x94b9cd7713f01579794b4a4a67e7c7dcc456d8d459689c9b668456d722d2a2e1;
    uint256 constant x7 = 0x38b3a8280315ac3c438d681eab7109c597ee19a8de062b2e2c76c47b0084456f;
    uint256 constant x8 = 0x908f0fd3a646551f3e826725d521788e9f01c2b093180cdc92ea1df8431a9aae;
    uint256 constant x9 = 0x7c2ea356da33ad034692689366bde7d7b501cc751f6e8a41685250f43bb1f318;
    uint256 constant x10 = 0xaf238c04974ed2ec5b159e49d526f8bf120856263e2432a96bd20c481f1d59da;
    uint256 constant x11 = 0x18ab106880f83cf82c8c11c07d5480350ff675c3fed160bf74bbbb24d98e006b;
    uint256 constant x12 = 0xdeaa47eb05f2179e437b0b71a7c95f8f00a99d3b3fc3c44472686f8e00fd01a9;
    uint256 constant x13 = 0xdedc0787c6af76267012fe76f2a5f7ce9a7b2eda5e57fcf24da0d4ad5c63b155;
    uint256 constant x14 = 0x34117375d4134c112ea774355278b6deab522c4cbc8fc702c94a09e4ebb93a9e;
    uint256 constant x15 = 0x91ecb65e4c52ecc68703bb52cb2d60aa30a0538a1514f10b157f63293429dc3d;
    uint256 constant x16 = 0x5db73eb2a7a1a9697286bd240df6881e3785ba5fcd04623a02758170d827f556;
    uint256 constant x17 = 0x99d9519184457eb158a7fb22d2967c5f4f0c33f64a02099ae090482194124036;
    uint256 constant x18 = 0x496a031b780b69c4cf1a492787a119b8cdfaf4f84cf9cd0f27c96a846d11117e;
    uint256 constant x19 = 0x7f8cf84774ceede5c88905e6602158417172875a736e993a010aa53c43d53c2b;
    uint256 constant x20 = 0xf0d91a930d983b56f816663ce5d133630a61737c09d5115083a5ac2f3e884905;
    uint256 constant x21 = 0x7b01aeb5600a6ea7b7678f7b72b38977068018f2ce6ae45b29188aa8e5a0b1e9;
    uint256 constant x22 = 0xc04c2b868bd14d75648781f3dbae1e0addcdd8aeab4d81a3446baaba1cc0c19d;
    uint256 constant x23 = 0x17be4f9082c0e65d676f9c955c708db26fd4c867a5106ef019dde49d78182f95;
    uint256 constant x24 = 0xd089cd81a32e98febe306c826cd83d8c037f1bde0b15722deddc1e2293c76559;
    uint256 constant x25 = 0x8a2f571b92cc81b4021b747767523904c95dbcccac17ee9d944e46bc0781867e;
    uint256 constant x26 = 0xc854dd9d26e2c30c858c04166d397708ebe29c58c80ced86d496b4abbe45e6f5;
    uint256 constant x27 = 0x10d24706acf8187a96f523cb2227e14378c365644643adc24729d97acff93e0d;
    uint256 constant x28 = 0x25484bbd91c6798e95f773f4442046752eda57ba06d313efeeaa44662dfa7530;
    uint256 constant x29 = 0xa8af0c9b39f1535e0cc2b7bd38a76c0e4f41071dcdaf247549a6eff801621748;
    uint256 constant x30 = 0x36ebacabbd6d9a2944d1cd6540815dfd55fa5a1a87cce9e9ae559b45d76b4c26;
    uint256 constant x31 = 0x637d60adde29f5f997491cbbfb350040ffe7f997201c9dcde61320e9a90987a3;
    uint256 constant x32 = 0xe24afa8361c1e6fccc87ff62f1c9d8fa4fd0454690ecc76e46e456b9305dceb8;
    uint256 constant x33 = 0xf627e68c2d286815c705bbfd101b6df3892dae62d5b7fb44ea1d5c945332e3cb;
    uint256 constant x34 = 0xf856f88ab341b0e928408d9d5421bc17eb9af9bc602371c567985a91d774907f;
    uint256 constant x35 = 0x7c4d697d9370b0b86ff5cebb7d465744674ceac0ea9102fc0de94784c793de69;
    uint256 constant x36 = 0xfe599bb1c6ad952f6d6ca9c3928c3f91f9022f0524a164dce5e98cd37649efdb;
    uint256 constant x37 = 0x6df3bcdb5d1e9ff117f5d010e2686ea16eac77fe7bb5c58588d90cbb18689163;
    uint256 constant x38 = 0x67c9efa5c0b76d9b960efbabbd87280770f4c47456c29d20d1541d1588137033;
    uint256 constant x39 = 0xe3f02b3eb6d9b28d53a077baeedcd29ea50a6c1d12c2801e52ba335b35984614;
    uint256 constant x40 = 0xe2599aa8af94ed1dd90d4767202c7d0777bec4f4fa71bc80fc5c8b768d0fbbfc;
    uint256 constant x41 = 0xda366dc68b32a0c71b36f7fc6642dcbc6fe7e7248b5fa782c42274043a7d1da7;
    uint256 constant x42 = 0x517ed6588a18df6d3e5c9b231fbd51ef1470601d3400389c676b065d8864ad80;
    uint256 constant x43 = 0xea6f1a9c2db484e1608785f08dd384af69d26699409c4e1677f9986a7f491266;
    uint256 constant x44 = 0x883ea6cfeaa06072fa2e5db5352594b49156bb89a2fbbbfbac3989c76e2422b1;
    uint256 constant x45 = 0x581f35601009a9b57e5ad9cda9fc0a6e43e5998e7f8778f9f038f8e15415c2e8;
    uint256 constant x46 = 0x6499b731b82389ae05d4d8190f06440ef1735aa0986430ee47ec952cbf149cc5;
    uint256 constant x47 = 0xb3cb2cb63f41e8c2271ac51b48ac5dedf76a0469717bba4d4f5c90d63b74f756;
    uint256 constant x48 = 0x1824110aa4fd43e31eb0507ca9375c08157c59a70cad8f51d66031a0abb5343f;
    uint256 constant x49 = 0xe533fa431996e2bbd7953a71d2529b9458f0fa074c9b1877057e990d8bfe19c4;
    uint256 constant x50 = 0xa8e2c0c999fcaada69d2aacadc1c4642f4d223077fe27e8c1366aa071594e637;
    uint256 constant x51 = 0xce1066bfdb9225529930b52aaeaa9a3e31ff7eb45e1f945a150ac49c0ccdac2d;
    uint256 constant x52 = 0xd8a8a217b82ea6e5d6a7465967b7e3e6836eef4ab6f900747fa3ea4bcb038123;
    uint256 constant x53 = 0xbf069f551fa83fc4d6ebdb2316f0a13719a7110d5ff3b55ffb633868b466f845;
    uint256 constant x54 = 0xbce0c19888404296ddbdd88b7fc5254663a553f8a728405a378a2bce6862e570;
    uint256 constant x55 = 0xefb77e7dc611625e32515c156984b765e84059769ba386fdd4eed4d9f8fe0309;
    uint256 constant x56 = 0x0ce54601baf879c2d85240571d8c1d7a72c0a3a95a1ffbde82f33a455143f446;
    uint256 constant x57 = 0x29c7e182e536c32f5a6f245b44272adbcb701d9cf76137ec0841f145e7042ecc;
    uint256 constant x58 = 0xf1277dd7745cf92ca8fe65fed3e2d7cf54c513ef6079bc2db66336b0101e383b;
    uint256 constant x59 = 0xbcd7575325be238a56a6f0beeeffcc175ea31f3d0ae772f5f76de3de1bbecdad;
    uint256 constant x60 = 0xc9107d43f7e38dce618358cd5c833f04f6975906de4177e567d314dcb4760f3e;
    uint256 constant x61 = 0x56ce58880e8345a8bff6b1bf78dfb112f1709c1e7bb8ed8b902402b9daa64ae0;
    uint256 constant x62 = 0x46b71d897eee035fbe37650999648f3a0863ea1f49ad888779bdecc53c10b568;
    uint256 constant x63 = 0x5f2e4bae04ef20ab72f8ce7b521e1ebe145255352e8af95b9094ccfdbcf36713;
    uint256 constant x64 = 0xc73953efd4b914746554ec2de3885c9603dc73b7931688a9cbbef1822b77cfc9;
    uint256 constant x65 = 0x632a32bdd2115dcc1ae5533d32684e134cc5a00413321bde62cbd38d78383a3b;
    uint256 constant x66 = 0xd00686f19f601ee77eaf23de3110c4929c3512097eb89d526d566eacc2efd226;
    uint256 constant x67 = 0x32e9fac55222727409f84725b8d0b60572291f0271b5c34b3dbfcbb804a02263;
    uint256 constant x68 = 0x55ba597fd4e4037dc813e1beffddeefac3c058f387010f2e1dfcf55fc694eeeb;
    uint256 constant x69 = 0xa9c01a7498c2fc6be57e1428dd265a71836b956d7e46ab1a5835d54150b32505;
    uint256 constant x70 = 0xe640913cbb486079fe496263113c5b6993cd66205efe823b2d657b40b46dfc6c;
    uint256 constant x71 = 0x57710c69fe9fadebb5f8728ae3224170ca28b751fdabae565ab12c3ca697c457;
    uint256 constant x72 = 0xd28fa2b7056579f29fd9d810e3557478d88d89aba72a94226d47abd0405bcbd9;
    uint256 constant x73 = 0x6f83ebaf13caec76fceb9ee22e922df7ce9856dfc05e93222772c854b67f2a32;
    uint256 constant x74 = 0x6d1af28d3a78cf77dff411e461c74ca9ed8b842e728808456e857085c6404932;
    uint256 constant x75 = 0xee37f6bc27116f485e9ec45a8ea2a51fa5573db7a746d036486b47685b438f3b;
    uint256 constant x76 = 0x18c54a5c64fcf08ee993cdc135c1ead39de07de7321b841c87423c5e071aa0f6;
    uint256 constant x77 = 0x962eb75bbb06bdd2dcdb5363389752f283d9cc88d014adc6c71121bb2372f938;
    uint256 constant x78 = 0xcaff265062be895156dccaffac4084c009712e951d3c288f1b085744e1d3cfef;
    uint256 constant x79 = 0x5c9a812e6611fd5985e460441981d8855a4c903f43f30d4b7d1d601bdd3c3391;
    uint256 constant x80 = 0x030ec65ec12878cd72e795fed0c76abd1ec085db7cbb61fa93e8dd1e8582eb06;
    uint256 constant x81 = 0x73563144049d4e7e5fd5aefe7b842a0075ced665bb32d4584e83bba78f15151f;
    uint256 constant x82 = 0x7795a125f0842455499af99d565cc7faa3b1278d3f27ce7496ca058e8a497443;
    uint256 constant x83 = 0xa6fb8caec115aa2117504923e4932402aea886c28eb79af5ebd5ea6bc7980d3b;
    uint256 constant x84 = 0x71369315796e6a663a7ec708b05175c8e02b74e7eb377ad36c8c1f54b980c374;
    uint256 constant x85 = 0x59aee281449cb799e01f5605ed0e085ec9a1a3b4aac481b1c935c39cb7d8ce7f;


    uint constant DELIMITER = 0x06;
    uint constant OUTPUT_LEN = 32;

    uint256 constant bitmatrix = 0xf5f17af93d7d1ebffaae88a7b1a2ad2156912b4915a50ad3f098784c3c26ebe3;
    uint256 constant coefficientsCon = 0x20d04031b031103120c04040c0707010416130e1f081a0c1612071f1b11080d;

    // TODO using assembly code to modify bytesToBytes32
    function bytesToBytes32(bytes memory b, uint offset) private pure returns (bytes32) {
        bytes32 out;
        for (uint i = 0; i < 32; i++) {
            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
        }
        return out;
    }

    function EaglesongHash(bytes memory data) internal pure returns (bytes32) {
        bytes memory output = EaglesongSponge(data, OUTPUT_LEN, DELIMITER);
        return bytesToBytes32(output, 0);
    }

    function EaglesongPermutation(uint[16] memory state) internal pure {
        uint N = 43;
        for (uint i=0; i<N; i++) {
            EaglesongRound(state, i * 2);
        }
    }

    function EaglesongRound(uint[16] memory state, uint i) internal pure {
        // bit matrix
        uint[16] memory _new;
        for (uint j=0; j<16; j++) {
            for (uint k=0; k<16; k++) {
                // !! modified
                uint8 tmp = uint8((bitmatrix >> (255 - k * 16 - j))) & 1;
                _new[j] = _new[j] ^ (state[k] * tmp);
            }
            _new[j] = _new[j] & 0xffffffff;
        }
        for (uint j=0; j<16; j++) {
            state[j] = _new[j];
        }

        // circulant multiplication
        for (uint i=0; i<16; i++) {
            uint acc = 0 ^ (state[i]) ^ (state[i] >> 32);
            for (uint j=1; j<3; j++) {
                // !!modified
                uint8 tmp = uint8(coefficientsCon >> ((31 - (j - 1) * 16 - i) * 8));
                acc = acc ^ (state[i] << tmp) ^ (state[i] >> (32 - tmp));
            }
            state[i] = acc & 0xffffffff; // truncate to 32 bits, if necessary
        }


        // constants injection
        {
            uint256 tmp1;
            uint256 tmp2;
            if (i == 0) {
            tmp1 = x0;
            tmp2 = x1;
        } else if (i == 2) {
            tmp1 = x2;
            tmp2 = x3;
        } else if (i == 4) {
            tmp1 = x4;
            tmp2 = x5;
        } else if (i == 6) {
            tmp1 = x6;
            tmp2 = x7;
        } else if (i == 8) {
            tmp1 = x8;
            tmp2 = x9;
        } else if (i == 10) {
            tmp1 = x10;
            tmp2 = x11;
        } else if (i == 12) {
            tmp1 = x12;
            tmp2 = x13;
        } else if (i == 14) {
            tmp1 = x14;
            tmp2 = x15;
        } else if (i == 16) {
            tmp1 = x16;
            tmp2 = x17;
        } else if (i == 18) {
            tmp1 = x18;
            tmp2 = x19;
        } else if (i == 20) {
            tmp1 = x20;
            tmp2 = x21;
        } else if (i == 22) {
            tmp1 = x22;
            tmp2 = x23;
        } else if (i == 24) {
            tmp1 = x24;
            tmp2 = x25;
        } else if (i == 26) {
            tmp1 = x26;
            tmp2 = x27;
        } else if (i == 28) {
            tmp1 = x28;
            tmp2 = x29;
        } else if (i == 30) {
            tmp1 = x30;
            tmp2 = x31;
        } else if (i == 32) {
            tmp1 = x32;
            tmp2 = x33;
        } else if (i == 34) {
            tmp1 = x34;
            tmp2 = x35;
        } else if (i == 36) {
            tmp1 = x36;
            tmp2 = x37;
        } else if (i == 38) {
            tmp1 = x38;
            tmp2 = x39;
        } else if (i == 40) {
            tmp1 = x40;
            tmp2 = x41;
        } else if (i == 42) {
            tmp1 = x42;
            tmp2 = x43;
        } else if (i == 44) {
            tmp1 = x44;
            tmp2 = x45;
        } else if (i == 46) {
            tmp1 = x46;
            tmp2 = x47;
        } else if (i == 48) {
            tmp1 = x48;
            tmp2 = x49;
        } else if (i == 50) {
            tmp1 = x50;
            tmp2 = x51;
        } else if (i == 52) {
            tmp1 = x52;
            tmp2 = x53;
        } else if (i == 54) {
            tmp1 = x54;
            tmp2 = x55;
        } else if (i == 56) {
            tmp1 = x56;
            tmp2 = x57;
        } else if (i == 58) {
            tmp1 = x58;
            tmp2 = x59;
        } else if (i == 60) {
            tmp1 = x60;
            tmp2 = x61;
        } else if (i == 62) {
            tmp1 = x62;
            tmp2 = x63;
        } else if (i == 64) {
            tmp1 = x64;
            tmp2 = x65;
        } else if (i == 66) {
            tmp1 = x66;
            tmp2 = x67;
        } else if (i == 68) {
            tmp1 = x68;
            tmp2 = x69;
        } else if (i == 70) {
            tmp1 = x70;
            tmp2 = x71;
        } else if (i == 72) {
            tmp1 = x72;
            tmp2 = x73;
        } else if (i == 74) {
            tmp1 = x74;
            tmp2 = x75;
        } else if (i == 76) {
            tmp1 = x76;
            tmp2 = x77;
        } else if (i == 78) {
            tmp1 = x78;
            tmp2 = x79;
        } else if (i == 80) {
            tmp1 = x80;
            tmp2 = x81;
        } else if (i == 82) {
            tmp1 = x82;
            tmp2 = x83;
        } else if (i == 84) {
            tmp1 = x84;
            tmp2 = x85;
        }


            // !!modified
            for (uint i=0; i<8; i++) {
                state[i] = state[i] ^ uint32(tmp1 >> ((7 - i) * 32)) ;
            }

            for (uint i=8; i<16; i++) {
                state[i] = state[i] ^ uint32(tmp2 >> ((15 - i) * 32)) ;
            }
        }

        // add / rotate / add
        for (uint i=0; i<8; i++) {
            state[2*i] = (state[2*i] + state[2*i+1]) & 0xffffffff; // truncate to 32 bits, if necessary
            state[2*i] = (state[2*i] >> 24) ^ ((state[2*i] << 8) & 0xffffffff); // shift bytes
            state[2*i+1] = (state[2*i+1] >> 8) ^ ((state[2*i+1] << 24) & 0xffffffff); // shift bytes
            state[2*i+1] = (state[2*i] + state[2*i+1]) & 0xffffffff; // truncate to 32 bits, if necessary
        }
    }

    function EaglesongSponge(bytes memory input, uint num_output_bytes, uint delimiter) internal pure returns (bytes memory output) {
        uint rate = 256;
        uint[16] memory state;

        // absorbing
        for (uint i=0; i<((input.length+1)*8+rate-1) / rate; i++) {
            for (uint j=0; j<rate/32; j++) {
                uint integer = 0;
                for (uint k=0; k<4; k++) {
                    if (i*rate/8 + j*4 + k < input.length) {
                        integer = (integer << 8) ^ uint8(input[i*rate/8+j*4+k]);
                    } else if (i*rate/8 + j*4 + k == input.length) {
                        integer = (integer << 8) ^ delimiter;
                    }
                }
                state[j] = state[j] ^ integer;
            }
            EaglesongPermutation(state);
        }

        // squeezing
        bytes memory output_bytes = new bytes(num_output_bytes);
        for (uint i=0; i<num_output_bytes/(rate/8); i++) {
            for (uint j=0; j<rate/32; j++) {
                for (uint k=0; k<4; k++) {
                    output_bytes[i*rate/8 + j*4 + k] = byte(uint8((state[j] >> (8*k)) & 0xff));
                }
            }
            // this condition is not in the python implementation.
            // It is not used in the final loop and may trigger unknown error in solidity,
            // so we add it here.
            if (i != num_output_bytes/(rate/8) - 1) {
                EaglesongPermutation(state);
            }
        }

        return output_bytes;
    }
}
